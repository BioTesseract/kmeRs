---
title: "Coding Challenge - k-mer.scoring.matrix" 	
output: 
  html_notebook: 
    code_folding: hide
author: Rafal Urniaz
---

 
```{r}

## -- Run once if needed -- 

source("https://bioconductor.org/biocLite.R")  # 
biocLite()
biocLite("Biostrings")
    
# Check packages availability and install if no available

list.of.packages <- c("kmer", "ape", "tcR", "rDNAse", "Biostrings", "stringi")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

```


```{r}

## -- Load required libraries --

library("stringi")
library("tcR")
library("kmer")
library("ape")
library("rDNAse")

source("k-mers.scoring.matrix.R")
source("k-mers.transcript_to_complementary.R")

## -- Prepare data -- 

  # Load list of 400 given hexamers

    hexamers.given <- c("ACCATG", "AACAAT", "TTAAAC", "CAAGAG", "ACCGTA")
    
  # Calculate similarity scoring matrix
    
    Matrix_A <- hexamers.scoring.matrix(hexamers.given, k = 6, save_to_file = 'hexamers.dist.matrix_A.csv' )
    
```
The hexamers are given : ```r hexamers.given```; should be 400 although the calculation only for example is too much time consuming


## Step I 

The similarity scoring matrix (all possible combination of hexamers, N= 4^6 = 4096 vs. given hexamers, here N=5) is calculated at this step.

hexamers.scoring.matrix is calculated as a pairwise similarity matrix for DNA k-mers using BLOSUM62 matrix then elementary scores are summed in additional column; the lower score the better. Here, the most different comparing to given hexamers is ```r rownames(Matrix_A)[1] ``` with score ```r Matrix_A[ 1, "score.global"] ``` (min= ```r min(Matrix_A[ , "score.global"]) ```, max= ```r max(Matrix_A[ , "score.global"]) ```, mean= ```r mean(Matrix_A[ , "score.global"]) ```, sd= ```r sd(Matrix_A[ , "score.global"]) ```)

```{r}    

    head(Matrix_A ,10)
    
  # hexamers.given - transcript as a complementary sequence 
    
   hexamers.given_complementary  <- hexamers.transcript_to_complementary(hexamers.given)
   
```

```{r}
    
   Matrix_B <- hexamers.scoring.matrix(hexamers.given_complementary, k = 6, save_to_file = 'hexamers.dist.matrix_B.csv' )
   
```

## Step II

To find duplexes, the given hexamers (```r hexamers.given```) are translated to complementary sequences: ```r hexamers.given_complementary``` and the scoring matrix is calculated (as above) for complementary hexamers. Here, the most different comparing to given hexamers is ```r rownames(Matrix_B)[1] ``` with score ```r Matrix_B[ 1, "score.global"] ``` (min= ```r min(Matrix_B[ , "score.global"]) ```, max= ```r max(Matrix_B[ , "score.global"]) ```, mean= ```r mean(Matrix_B[ , "score.global"]) ```, sd= ```r sd(Matrix_B[ , "score.global"]) ```)

```{r}
    
   head(Matrix_B ,10)
   
   # Find most different duplex
   
   hexamers.duplex <- merge(Matrix_A[,], Matrix_B, by=0, all=TRUE)
   
   hexamers.duplex <- hexamers.duplex[, c("Row.names", "score.global.x", "score.global.y")]
   colnames(hexamers.duplex) <- c("Hexamers.all", "Score.given", "Score.complementary")
   
   score.sum <- apply(hexamers.duplex[, c(2,3)], 1, sum)
   
   hexamers.duplex <- cbind(hexamers.duplex, score.sum)
   
   hexamers.duplex <- hexamers.duplex[order(hexamers.duplex$score.sum, decreasing = FALSE),]
   
```   
## Step III

To find the most different duplex from both given hexamers (A) and complementary (B), the sum of both scoring (A+B) is calculated; the lowest value indicates the most different sequence. Here, ```r hexamers.duplex[1,1] ``` and its complementary sequence: ```r hexamers.transcript_to_complementary(hexamers.duplex[1,1]) ```.

```{r}
   
   head(hexamers.duplex ,1)

```

